유저 입력이 없어도 페르소나들이 스스로 대화를 이어가는 기능(MVP)을 추가한다: 오케스트레이터 + 턴 스케줄러 + 대화 정책. 포스트 생성/유저 메시지/아이들틱 때 1~3턴의 자동 대화가 발생하고, 유사도/쿨다운/연속 발언 제한을 적용한다.

0) 프로젝트 전제

서버 런타임: Node.js/TypeScript

이미 존재: server/engine/persoRoom.ts (PersoRoomManager), server/api/analyze.ts (subjects/contexts/sentiment/tones 반환)

LLM 키 없으면 로컬 스텁으로 동작하도록 만들기

1) 새 타입 및 정책 추가

파일: server/engine/types.ts (없으면 생성)

export type PersonaPlan = {
  personaId: string;
  intent: 'agree'|'disagree'|'ask'|'share'|'joke'|'meta';
  targetPersonaId?: string;
  topicTags: string[];
  novelty: number;
  relevance: number;
  energy: number;
  reason: string;
};

export type AutoChatPolicy = {
  maxTurnsPerBurst: number;
  maxConsecutiveBySame: number;
  minSecondsBetweenBursts: number;
  perPersonaCooldownSec: number;
  similarityThreshold: number;
};


파일: server/engine/policies.ts

import { AutoChatPolicy } from './types';

export const DEFAULT_AUTO_CHAT_POLICY: AutoChatPolicy = {
  maxTurnsPerBurst: 3,
  maxConsecutiveBySame: 1,
  minSecondsBetweenBursts: 20,
  perPersonaCooldownSec: 30,
  similarityThreshold: 0.92,
};

2) 텍스트 유사도 유틸

파일: server/engine/textSim.ts

export function similarity(a: string, b: string) {
  // 아주 단순 Jaccard-like 유사도(토큰 집합 기반)
  const ta = new Set(a.toLowerCase().split(/\W+/).filter(Boolean));
  const tb = new Set(b.toLowerCase().split(/\W+/).filter(Boolean));
  const inter = [...ta].filter(x => tb.has(x)).length;
  const uni = new Set([...ta, ...tb]).size || 1;
  return inter / uni;
}

3) LLM 발화 생성 래퍼 (키 없으면 스텁)

파일: server/engine/llm.ts

type GenArgs = {
  personaId: string,
  context: { subjects: string[], contexts: string[], tones: string[], sentiment: number },
  roomMessages: {personaId?: string; text: string}[],
  intent: string,
  targetPersonaId?: string
};

export async function generatePersonaLine(args: GenArgs): Promise<string> {
  const persona = await loadPersona(args.personaId); // 구현체는 프로젝트 로더에 맞추기
  const recent = args.roomMessages.slice(-6).map(m => `${m.personaId ?? 'User'}: ${m.text}`).join('\n');

  // 실제 키 확인
  const hasKey = !!process.env.OPENAI_API_KEY;

  if (!hasKey) {
    // 스텁: 의도/주제 반영한 짧은 한줄 생성
    const tag = args.context.subjects[0] ?? 'topic';
    const tone = args.context.tones?.[0] ?? 'neutral';
    return `[stub:${persona.name}/${args.intent}] ${tag}에 대해 ${tone} 톤으로 한마디.";
  }

  // TODO: 실제 LLM 호출부(필요시 OpenAI/Vertex 연결)
  // 여기선 간결한 한 줄 답변 반환하도록 모델 프롬프트 설계
  return await realLLM(persona, recent, args);
}

// 프로젝트에 맞게 구현/교체
async function loadPersona(personaId: string) {
  // 예시: DB 또는 in-memory에서
  return { id: personaId, name: personaId, traits: ['curious'], speechStyle: 'concise', maxChars: 180 };
}

async function realLLM(persona: any, recent: string, args: GenArgs): Promise<string> {
  // 실제 LLM 프롬프트 구성(요약)
  // return callOpenAI({system, user})
  return `[llm:${persona.name}] (${args.intent}) ${args.context.subjects.join(', ')} 관련 짧은 코멘트`;
}

4) 오케스트레이터

파일: server/engine/autoChatOrchestrator.ts

import { analyzeContext } from '../api/analyze';
import { generatePersonaLine } from './llm';
import { computePersonaDeltas } from './personaGrowth'; // 기존 함수 연결
import { similarity } from './textSim';
import { DEFAULT_AUTO_CHAT_POLICY } from './policies';
import { PersonaPlan } from './types';
import { PersoRoomManager } from './persoRoom';

export class AutoChatOrchestrator {
  private roomId: string;
  private policy = DEFAULT_AUTO_CHAT_POLICY;
  private lastBurstAt = 0;
  private personaCooldown: Map<string, number> = new Map();

  constructor(roomId: string) { this.roomId = roomId; }

  async runBurst(trigger: 'post_created'|'user_message'|'idle_tick') {
    const now = Date.now();
    if (now - this.lastBurstAt < this.policy.minSecondsBetweenBursts * 1000) return;
    this.lastBurstAt = now;

    const room = PersoRoomManager.get(this.roomId);
    if (!room || !room.autoChatEnabled) return;

    const ctx = await analyzeContext({
      postId: room.postId,
      lastMessages: room.getLastMessages(12)
    });

    let turns = 0;
    let lastSpeaker: string | null = null;

    while (turns < this.policy.maxTurnsPerBurst) {
      const candidates = await this.planCandidates(room, ctx, lastSpeaker);
      if (candidates.length === 0) break;

      const speaker = this.selectSpeaker(candidates, lastSpeaker);
      if (!speaker) break;

      const text = await generatePersonaLine({
        personaId: speaker.personaId,
        context: ctx,
        roomMessages: room.getLastMessages(12),
        intent: speaker.intent,
        targetPersonaId: speaker.targetPersonaId,
      });

      const prev = room.getLastMessages(6).map(m => m.text).join('\n');
      if (similarity(prev, text) >= this.policy.similarityThreshold) {
        this.setCooldown(speaker.personaId);
        continue;
      }

      room.addMessage({
        personaId: speaker.personaId,
        text,
        createdAt: new Date()
      });

      computePersonaDeltas({
        personaId: speaker.personaId,
        text,
        subjects: ctx.subjects,
        tones: ctx.tones,
      });

      this.setCooldown(speaker.personaId);
      lastSpeaker = speaker.personaId;
      turns++;

      if (this.exceedsConsecutiveLimit(room, lastSpeaker)) break;
    }
  }

  private async planCandidates(room: any, ctx: any, lastSpeaker: string|null): Promise<PersonaPlan[]> {
    const personas = room.getActivePersonas();
    const now = Date.now();
    const plans: PersonaPlan[] = [];

    for (const p of personas) {
      const until = this.personaCooldown.get(p.id) ?? 0;
      if (until > now) continue;
      if (lastSpeaker === p.id) continue;

      const intent = this.pickIntent(ctx);
      const target = this.pickTarget(room, p.id);

      const novelty = Math.random();
      const relevance = Math.random();
      const energy = Math.random();

      if (relevance + energy + novelty > 1.2) {
        plans.push({
          personaId: p.id,
          intent, targetPersonaId: target,
          topicTags: ctx.subjects.slice(0,3),
          novelty, relevance, energy,
          reason: 'heuristic v1'
        });
      }
    }

    return plans.sort((a,b) =>
      (b.relevance*0.45 + b.energy*0.35 + b.novelty*0.2) -
      (a.relevance*0.45 + a.energy*0.35 + a.novelty*0.2)
    ).slice(0, 2);
  }

  private selectSpeaker(plans: PersonaPlan[], lastSpeaker: string|null) {
    return plans.find(p => p.personaId !== lastSpeaker) ?? null;
  }

  private setCooldown(personaId: string) {
    const until = Date.now() + DEFAULT_AUTO_CHAT_POLICY.perPersonaCooldownSec*1000;
    this.personaCooldown.set(personaId, until);
  }

  private exceedsConsecutiveLimit(room: any, personaId: string) {
    const last = room.getLastMessages(DEFAULT_AUTO_CHAT_POLICY.maxConsecutiveBySame);
    return last.length > 0 && last.every((m: any) => m.personaId === personaId);
  }

  private pickIntent(ctx: any): PersonaPlan['intent'] {
    return (ctx.sentiment > 0 ? (Math.random() > 0.5 ? 'ask' : 'share') : (Math.random() > 0.5 ? 'disagree' : 'meta'));
  }

  private pickTarget(room: any, selfId: string) {
    const others = room.getActivePersonas().map((x: any)=>x.id).filter((id: string) => id !== selfId);
    return others.length ? others[Math.floor(Math.random()*others.length)] : undefined;
  }
}

5) 스케줄러 & 트리거 훅

파일: server/engine/autoTick.ts

import { AutoChatOrchestrator } from './autoChatOrchestrator';
import { PersoRoomManager } from './persoRoom';

const orchestrators = new Map<string, AutoChatOrchestrator>();

function ensureOrchestrator(roomId: string) {
  if (!orchestrators.has(roomId)) {
    orchestrators.set(roomId, new AutoChatOrchestrator(roomId));
  }
  return orchestrators.get(roomId)!;
}

export function onPostCreated(roomId: string) {
  const orch = ensureOrchestrator(roomId);
  orch.runBurst('post_created');
}

export function onUserMessage(roomId: string) {
  const orch = ensureOrchestrator(roomId);
  orch.runBurst('user_message');
}

setInterval(async () => {
  for (const roomId of PersoRoomManager.ids()) {
    const room = PersoRoomManager.get(roomId);
    if (!room || !room.autoChatEnabled) continue;

    const quietMs = Date.now() - (room.lastMessageAt?.getTime?.() ?? 0);
    if (quietMs > 120000 && Math.random() < 0.3) {
      const orch = ensureOrchestrator(roomId);
      await orch.runBurst('idle_tick');
    }
  }
}, 10000);


연결 지점:

포스트 생성 시: onPostCreated(roomId) 호출

유저 메시지 수신 후: onUserMessage(roomId) 호출

PersoRoom에 autoChatEnabled: boolean 기본값 true 권장

6) API 엔드포인트(관리/테스트)

파일: server/api/autoChat.ts (신규)

import { Router } from 'express';
import { PersoRoomManager } from '../engine/persoRoom';
import { AutoChatOrchestrator } from '../engine/autoChatOrchestrator';

export const autoChat = Router();

autoChat.post('/rooms/:roomId/auto/enable', (req, res) => {
  const room = PersoRoomManager.get(req.params.roomId);
  if (!room) return res.status(404).json({error:'room not found'});
  room.autoChatEnabled = true;
  res.json({ ok: true });
});

autoChat.post('/rooms/:roomId/auto/disable', (req, res) => {
  const room = PersoRoomManager.get(req.params.roomId);
  if (!room) return res.status(404).json({error:'room not found'});
  room.autoChatEnabled = false;
  res.json({ ok: true });
});

autoChat.post('/rooms/:roomId/auto/warmup', async (req, res) => {
  const roomId = req.params.roomId;
  const orch = new AutoChatOrchestrator(roomId);
  await orch.runBurst('post_created');
  res.json({ ok: true });
});


서버 진입점에서 라우터 연결:

// server/index.ts (또는 app.ts)
import { autoChat } from './api/autoChat';
app.use('/api/auto', autoChat);

7) 프런트엔드 UI 훅(간단)

Persona 대화 페이지 상단:

Auto-chatter 토글 → /api/auto/rooms/:roomId/auto/enable|disable

Warm-up now 버튼 → /api/auto/rooms/:roomId/auto/warmup

Tempo 슬라이더는 서버 정책 바인딩 생략(MVP)

8) PersoRoom 보완 포인트

server/engine/persoRoom.ts에 다음이 있어야 함:

postId, autoChatEnabled: boolean

getActivePersonas(): {id: string}[]

getLastMessages(n: number)

addMessage({personaId, text, createdAt})

lastMessageAt 최신화

누락 시 최소 구현/보완.

9) 테스트 시나리오 (Postman/브라우저 콘솔)

포스트 열고 방 생성 시 room.autoChatEnabled = true 확인

유저가 “안녕” 보낸 직후, 10초 내 1~3개의 페르소나 메시지 자동 등장(연쇄)

2분 이상 조용하면 30% 확률로 아이들 버스트 발생

관리자 수동 트리거:

POST /api/auto/rooms/{roomId}/auto/warmup → 즉시 몇 턴 생성

POST /api/auto/rooms/{roomId}/auto/enable|disable

같은 페르소나 연속 발언 금지, 중복/유사 텍스트 drop(유사도 ≥ 0.92)

10) 성공 기준 (Acceptance)

 유저 입력 없이도 자동 대화가 주기적으로 1~3턴 생성됨

 동일 페르소나 연속 발언 제한 동작

 과도한 중복 문장 생성 시 drop 처리

 토스트/로그에 computePersonaDeltas 결과가 반영됨(예: “Empathy +1 · Creativity +1”)

 토글/워밍업 API로 on/off와 즉시 실행 가능